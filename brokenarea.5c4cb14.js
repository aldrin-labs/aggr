const e="\n\n```ts\nbrokenarea(cell: BrokenAreaCell, [options])\n```\n\nDraws a \"broken cloud,\" or a shape with both a top and bottom value, capable of stopping and reappearing elsewhere without continuity. The `brokenarea` function is flexible enough to create rectangles, background fills, and even horizontal lines, enabling advanced plotting capabilities. When applied correctly, it can generate complex visualizations like heatmaps.\n\n## Parameters\n\n- **`cell`** — Defines the primary characteristics of the broken area.\n- **`options`** *(optional)* — Allows additional customization, such as color and stroke properties.\n\n## `BrokenAreaCell` Type\n\n```ts\nexport interface BrokenAreaCell {\n  time: number;             // Unix timestamp\n  lowerValue: number;\n  higherValue: number;\n  extendRight?: boolean;\n  infinite?: boolean;       // Draw beyond viewport if set to true\n  color?: string;\n  label?: string;\n  id?: string;\n}\n```\n\n## `BrokenAreaOptions` Type\n\n```ts\nexport interface BrokenAreaOptions {\n  color?: string;\n  strokeColor?: string;\n  strokeWidth?: number;\n}\n```\n\n## Example Usage\n\n### Basic Example (Suboptimal Usage)\n\n```\nbrokenarea({\n  time: time,\n  lowerValue: 10,\n  higherValue: 20,\n  extendRight: true,\n  color: 'yellow'\n})\n```\n\nThis example draws a rectangle extending infinitely to the right, which can function as a test but lacks practical application.\n\n### Advanced Example (Dynamic Slot-Based Drawing)\n\nThe `brokenarea` function is most effective when used to dynamically allocate slots for drawing lines or rectangles on the chart. By defining multiple `brokenarea` slots programmatically, you gain greater control over redrawing and updating visual elements based on script logic.\n\n```ts\n// top of the script\nif (!boundaries) {\n  // check if boundaries isn't defined = initial run of the script\n\n  // define some persistent script variables\n  pendingRedraws = [] // number[]\n  slots = [] // {index: number, redrawAt: number}[]\n\n  // indicator related, but usefull to underestand the point\n  cells = [] // {[normalizedCellPrice: number]: {strength: number, index: number, top: number, bottom: number, count: number}\n\n  // here we make use of the series global variable\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    slots.push({\n      index: i,\n      redrawAt: 0\n    })\n\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n// define the slots at whatever part of the script\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\nbrokenarea()\n```\n\nThis binds the `boundaries` object to each series slot, allowing control over where each cell extension halts.\n\n```ts\n// at the bottom of the script, you would have something like this\n// pendingRedraws here is an array of the cells that needs to be redrawn, each redraw use another object `cells`, a store for all the cells\nif (pendingRedraws.length) {\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = cells[pendingRedraws[i]]\n\n    if (!cell) {\n      // maybe cell doesn't exist anymore\n      pendingRedraws.splice(i--, 1)\n      continue\n    }\n    \n    var slot = slots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      // lock that slot to NOT be used until next bar\n      slot.redrawAt = bar.length + 1\n\n      if (cell.id) {\n        // this is the interesting part. it tells the cell previously drawn by that slot (with extendRight: true) to stop extending at the bar index `bar.length - 2`\n        boundaries[cell.id] = bar.length - 2\n      }\n      \n      // register a new cell id\n      cell.id = Math.random().toString()\n\n      // indicator related stuff based on our cell\n      var ratio = Math.max(0.01, Math.min(1, cell.strength * cell.count * (options.strength / 100)))\n      var color = interpolate(ratio, color0, color1, color2, color3)\n\n      // this is the second interesting part. it just tells the selected brokenarea() slot (bar.series[series[slot.index].id]) to draw the rectangle\n      bar.series[series[slot.index].id] ={\n        id: cell.id,\n        time: time - bar.timeframe,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: color\n      }\n\n      pendingRedraws.splice(i--, 1)\n    } else {\n      break;\n    }\n  }\n}\n```\n\nThis setup provides efficient control over drawing, only updating cells that have changed. With proper configuration, this approach forms the basis for heatmap visualizations by selectively redrawing areas as needed.\n\n### Horizontal lines\n\nThe `brokenarea` function can also create horizontal lines, offering programmable and efficient rendering. Setting `lowerValue` and `higherValue` to the same value draws a line instead of a rectangle.\n\nExample: Drawing a horizontal threshold line above a histogram series.\n\n```ts\nthreshold = option(default=1000000,type=range,step=10000,min=1000,max=10000000)\nbrokenarea(infinite=true,strokeWidth=0.5,strokeColor=options.upColor,id=threshold)\n\nif (bar.length === 1) {\n  // draw once\n  bar.series.threshold = { time: time, lowerValue: options.threshold, higherValue: options.threshold, extendRight: true }\n}\n```\n\nWith `brokenarea`, precise control over plot boundaries and appearance is possible, enabling a high degree of customization across various charting applications.\n";export{e as default};
